<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>City Traffic Simulator: Event::Manager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">City Traffic Simulator
   &#160;<span id="projectnumber">0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Event</b></li><li class="navelem"><a class="el" href="class_event_1_1_manager.html">Manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_event_1_1_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Event::Manager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores events that can be active or not.  
 <a href="class_event_1_1_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event_2_manager_8h_source.html">Manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager_1_1_set_inner.html">SetInner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad643d7f34cb7ae4ceb7dda35f5c2f278"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">State</a> { <b>ACTIVE</b>, 
<b>INACTIVE</b>
 }</td></tr>
<tr class="memdesc:ad643d7f34cb7ae4ceb7dda35f5c2f278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to set the mode. Active event set will be included while checking event. Inactive event set will not be included while checking event.  <a href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">More...</a><br /></td></tr>
<tr class="separator:ad643d7f34cb7ae4ceb7dda35f5c2f278"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af91d9a37ea254cad352a4e8335eae490"><td class="memItemLeft" align="right" valign="top"><a id="af91d9a37ea254cad352a4e8335eae490"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Manager</b> (const std::shared_ptr&lt; <a class="el" href="class_screen_master_1_1_view.html">ScreenMaster::View</a> &gt; &amp;view)</td></tr>
<tr class="separator:af91d9a37ea254cad352a4e8335eae490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f87258dee7cfcbc9d9e4461942a48b"><td class="memItemLeft" align="right" valign="top"><a id="a88f87258dee7cfcbc9d9e4461942a48b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Manager</b> (const <a class="el" href="class_event_1_1_manager.html">Manager</a> &amp;)=delete</td></tr>
<tr class="separator:a88f87258dee7cfcbc9d9e4461942a48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c10b85d66d10e05ae655cd1a3a4ac9"><td class="memItemLeft" align="right" valign="top"><a id="a55c10b85d66d10e05ae655cd1a3a4ac9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Manager</b> (<a class="el" href="class_event_1_1_manager.html">Manager</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a55c10b85d66d10e05ae655cd1a3a4ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6be5cd683b2b555da2f5760dfe2693"><td class="memItemLeft" align="right" valign="top"><a id="a5d6be5cd683b2b555da2f5760dfe2693"></a>
<a class="el" href="class_event_1_1_manager.html">Manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_event_1_1_manager.html">Manager</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a5d6be5cd683b2b555da2f5760dfe2693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7567f23722ca23743dcbb752acf6d95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#ad7567f23722ca23743dcbb752acf6d95">add</a> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;event_object_set)</td></tr>
<tr class="memdesc:ad7567f23722ca23743dcbb752acf6d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new event set. If the event set with that name existed before, it will delete it and change to the new set. All events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> must be the same type. Depending on the type set will be used as ordinary event or as event that can toggle other events.  <a href="class_event_1_1_manager.html#ad7567f23722ca23743dcbb752acf6d95">More...</a><br /></td></tr>
<tr class="separator:ad7567f23722ca23743dcbb752acf6d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75c6ac553c7672e26b78da2de6a3016"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#ad75c6ac553c7672e26b78da2de6a3016">addNew</a> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;event_object_set)</td></tr>
<tr class="memdesc:ad75c6ac553c7672e26b78da2de6a3016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new event set. If the event set with that name exists, it will return a value. All events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> must be the same type. Depending on the type set will be used as ordinary event or as event that can toggle other events.  <a href="class_event_1_1_manager.html#ad75c6ac553c7672e26b78da2de6a3016">More...</a><br /></td></tr>
<tr class="separator:ad75c6ac553c7672e26b78da2de6a3016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02fabbde1b738b3b7ad020d0cb9c9d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#ab02fabbde1b738b3b7ad020d0cb9c9d3">add</a> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;event_object)</td></tr>
<tr class="memdesc:ab02fabbde1b738b3b7ad020d0cb9c9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new event to the set. If the set with that name do not exist, then it creates a new set. It can be used to adds a new functionality to the existing set. Event will be stored depending on its interface.  <a href="class_event_1_1_manager.html#ab02fabbde1b738b3b7ad020d0cb9c9d3">More...</a><br /></td></tr>
<tr class="separator:ab02fabbde1b738b3b7ad020d0cb9c9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4071b96640a00c589a94ebe76bd75b9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a4071b96640a00c589a94ebe76bd75b9a">addNew</a> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;event_object)</td></tr>
<tr class="memdesc:a4071b96640a00c589a94ebe76bd75b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new event. If the event set with that name existed before, it will return a value. Event will be stored depending on its interface.  <a href="class_event_1_1_manager.html#a4071b96640a00c589a94ebe76bd75b9a">More...</a><br /></td></tr>
<tr class="separator:a4071b96640a00c589a94ebe76bd75b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2f4e4ae4918203856a24f9797a2315"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a8a2f4e4ae4918203856a24f9797a2315">changeMode</a> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode)</td></tr>
<tr class="memdesc:a8a2f4e4ae4918203856a24f9797a2315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change mode to Active / Inactive. It can be used on both type of events.  <a href="class_event_1_1_manager.html#a8a2f4e4ae4918203856a24f9797a2315">More...</a><br /></td></tr>
<tr class="separator:a8a2f4e4ae4918203856a24f9797a2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bd2bca85508b0faa40edce7152c2c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a67bd2bca85508b0faa40edce7152c2c9">remove</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a67bd2bca85508b0faa40edce7152c2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the set of events identified by name.  <a href="class_event_1_1_manager.html#a67bd2bca85508b0faa40edce7152c2c9">More...</a><br /></td></tr>
<tr class="separator:a67bd2bca85508b0faa40edce7152c2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38142bb61b9ed3c0acfd27ef68c3264e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a38142bb61b9ed3c0acfd27ef68c3264e">remove</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;event_object)</td></tr>
<tr class="memdesc:a38142bb61b9ed3c0acfd27ef68c3264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove specific event from the set.  <a href="class_event_1_1_manager.html#a38142bb61b9ed3c0acfd27ef68c3264e">More...</a><br /></td></tr>
<tr class="separator:a38142bb61b9ed3c0acfd27ef68c3264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cd38b7da27595f380e4462b985ad1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a55cd38b7da27595f380e4462b985ad1b">checkEvents</a> (sf::RenderWindow &amp;window, sf::Event &amp;event)</td></tr>
<tr class="memdesc:a55cd38b7da27595f380e4462b985ad1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run and check occurence in all active events. While using it, it checks if vector is sorted. If not then it performs a simple sort on binary values with computational complexity O(n) which is not heavy assumed that there will be only several dozens of sets.  <a href="class_event_1_1_manager.html#a55cd38b7da27595f380e4462b985ad1b">More...</a><br /></td></tr>
<tr class="separator:a55cd38b7da27595f380e4462b985ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a2cd01fbd20489cdc1a3d4eba2055f3cd"><td class="memItemLeft" align="right" valign="top"><a id="a2cd01fbd20489cdc1a3d4eba2055f3cd"></a>
typedef std::shared_ptr&lt; <a class="el" href="class_event_1_1_manager_1_1_set_inner.html">SetInner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pointer</b></td></tr>
<tr class="separator:a2cd01fbd20489cdc1a3d4eba2055f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c2210e1e995205cb527e3df13dd72e"><td class="memItemLeft" align="right" valign="top"><a id="a00c2210e1e995205cb527e3df13dd72e"></a>
typedef std::map&lt; std::string, Pointer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b></td></tr>
<tr class="separator:a00c2210e1e995205cb527e3df13dd72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedafc55403a3119fbc0f94460fb18c91"><td class="memItemLeft" align="right" valign="top"><a id="aedafc55403a3119fbc0f94460fb18c91"></a>
typedef std::list&lt; Pointer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b></td></tr>
<tr class="separator:aedafc55403a3119fbc0f94460fb18c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9431b4dfbd8c643b86aa5264278873"><td class="memItemLeft" align="right" valign="top"><a id="a7c9431b4dfbd8c643b86aa5264278873"></a>
typedef std::pair&lt; std::reference_wrapper&lt; <a class="el" href="class_event_1_1_manager_1_1_set_inner.html">SetInner</a> &gt;, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MyPair</b></td></tr>
<tr class="separator:a7c9431b4dfbd8c643b86aa5264278873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af572a514aa5e72c1d75d36fcbec64345"><td class="memItemLeft" align="right" valign="top"><a id="af572a514aa5e72c1d75d36fcbec64345"></a>
typedef std::vector&lt; MyPair &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ToChange</b></td></tr>
<tr class="separator:af572a514aa5e72c1d75d36fcbec64345"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abb9fff65930bf1071b65199335634dfb"><td class="memItemLeft" align="right" valign="top"><a id="abb9fff65930bf1071b65199335634dfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#abb9fff65930bf1071b65199335634dfb">sortListBinaryVal</a> ()</td></tr>
<tr class="memdesc:abb9fff65930bf1071b65199335634dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort list only by binary value. Computational complexity O(n). <br /></td></tr>
<tr class="separator:abb9fff65930bf1071b65199335634dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a24d2ffbbf0a85009db3f78abd347d2"><td class="memItemLeft" align="right" valign="top"><a id="a0a24d2ffbbf0a85009db3f78abd347d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ifElementMapExist</b> (const std::string &amp;name, Map::iterator &amp;it)</td></tr>
<tr class="separator:a0a24d2ffbbf0a85009db3f78abd347d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8784c3e22e0a2c077012f7f4022f6362"><td class="memItemLeft" align="right" valign="top"><a id="a8784c3e22e0a2c077012f7f4022f6362"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ifElementMapExist</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a8784c3e22e0a2c077012f7f4022f6362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096ae3b1cd872950cca9c70bc36e87cf"><td class="memItemLeft" align="right" valign="top"><a id="a096ae3b1cd872950cca9c70bc36e87cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addNewEventInterface</b> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;event_object)</td></tr>
<tr class="separator:a096ae3b1cd872950cca9c70bc36e87cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9b0e8a5c0c00158fe3c19d2b8c8018"><td class="memItemLeft" align="right" valign="top"><a id="a4f9b0e8a5c0c00158fe3c19d2b8c8018"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDifferentType</b> (const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;event_object_set)</td></tr>
<tr class="separator:a4f9b0e8a5c0c00158fe3c19d2b8c8018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacb98b519f812c68cab3ba494746d01"><td class="memItemLeft" align="right" valign="top"><a id="adacb98b519f812c68cab3ba494746d01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>runChangeMode</b> ()</td></tr>
<tr class="separator:adacb98b519f812c68cab3ba494746d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397cddbcc84a822da7913fcc5fd62d09"><td class="memItemLeft" align="right" valign="top"><a id="a397cddbcc84a822da7913fcc5fd62d09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addInner</b> (const std::string &amp;name, <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a> mode, const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;event_object_set)</td></tr>
<tr class="separator:a397cddbcc84a822da7913fcc5fd62d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeec71b2a44e6941aa5c1bb6dbcf8ab2f"><td class="memItemLeft" align="right" valign="top"><a id="aeec71b2a44e6941aa5c1bb6dbcf8ab2f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#aeec71b2a44e6941aa5c1bb6dbcf8ab2f">events_sorted_</a></td></tr>
<tr class="memdesc:aeec71b2a44e6941aa5c1bb6dbcf8ab2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A boolean to know if the sets are sorted by Active / Inactive. <br /></td></tr>
<tr class="separator:aeec71b2a44e6941aa5c1bb6dbcf8ab2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a137c2723708d80d2c08a91fed2e1e6"><td class="memItemLeft" align="right" valign="top"><a id="a2a137c2723708d80d2c08a91fed2e1e6"></a>
Map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a2a137c2723708d80d2c08a91fed2e1e6">events_map_names_</a></td></tr>
<tr class="memdesc:a2a137c2723708d80d2c08a91fed2e1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map names with event sets. <br /></td></tr>
<tr class="separator:a2a137c2723708d80d2c08a91fed2e1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e69c5ff64ccbf975f07c62d6c9b0e2"><td class="memItemLeft" align="right" valign="top"><a id="ac6e69c5ff64ccbf975f07c62d6c9b0e2"></a>
List&#160;</td><td class="memItemRight" valign="bottom"><b>events_sorted_list_</b></td></tr>
<tr class="separator:ac6e69c5ff64ccbf975f07c62d6c9b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a0fd9819101372b9d68ca08cc0c5da"><td class="memItemLeft" align="right" valign="top">Map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#a91a0fd9819101372b9d68ca08cc0c5da">enents_change_control_map_names_</a></td></tr>
<tr class="memdesc:a91a0fd9819101372b9d68ca08cc0c5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map names with event sets that is used for events, that change state of other events in this <a class="el" href="class_event_1_1_manager.html" title="Stores events that can be active or not.">Manager</a>.  <a href="class_event_1_1_manager.html#a91a0fd9819101372b9d68ca08cc0c5da">More...</a><br /></td></tr>
<tr class="separator:a91a0fd9819101372b9d68ca08cc0c5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd233b3484ad3b61219cb7fabdbccd4"><td class="memItemLeft" align="right" valign="top"><a id="a6cd233b3484ad3b61219cb7fabdbccd4"></a>
List&#160;</td><td class="memItemRight" valign="bottom"><b>enents_change_control_list_</b></td></tr>
<tr class="separator:a6cd233b3484ad3b61219cb7fabdbccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae115b91894555ee4465b26957e288b8"><td class="memItemLeft" align="right" valign="top"><a id="aae115b91894555ee4465b26957e288b8"></a>
ToChange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_event_1_1_manager.html#aae115b91894555ee4465b26957e288b8">tmp_mode_</a></td></tr>
<tr class="memdesc:aae115b91894555ee4465b26957e288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember to change modes at the next checkEvents iteration. <br /></td></tr>
<tr class="separator:aae115b91894555ee4465b26957e288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c60dd2088adaad99285f18dd88d73e9"><td class="memItemLeft" align="right" valign="top"><a id="a7c60dd2088adaad99285f18dd88d73e9"></a>
std::shared_ptr&lt; <a class="el" href="class_screen_master_1_1_view.html">ScreenMaster::View</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>view_</b></td></tr>
<tr class="separator:a7c60dd2088adaad99285f18dd88d73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17f309716930c22c16a4825efb4ae4b"><td class="memItemLeft" align="right" valign="top"><a id="aa17f309716930c22c16a4825efb4ae4b"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_modify_</b></td></tr>
<tr class="separator:aa17f309716930c22c16a4825efb4ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa6f4ab003e9fa7bb40a5a77a391cfb5a"><td class="memItemLeft" align="right" valign="top"><a id="aa6f4ab003e9fa7bb40a5a77a391cfb5a"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_HASH_MAP_SIZE</b> = 30</td></tr>
<tr class="separator:aa6f4ab003e9fa7bb40a5a77a391cfb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores events that can be active or not. </p>
<p>Active events will be used in event checking. Events can be added as EventSet or directly. Each set have a name that identify it. Only a set of events can be active or inactive. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad643d7f34cb7ae4ceb7dda35f5c2f278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad643d7f34cb7ae4ceb7dda35f5c2f278">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Event::Manager::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to set the mode. Active event set will be included while checking event. Inactive event set will not be included while checking event. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7567f23722ca23743dcbb752acf6d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7567f23722ca23743dcbb752acf6d95">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>event_object_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new event set. If the event set with that name existed before, it will delete it and change to the new set. All events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> must be the same type. Depending on the type set will be used as ordinary event or as event that can toggle other events. </p>
<p>Different sets can have part of the same functionality, so it is up to developer to watch out for them. Also it is possible that the same event will have different approach in two or more sets and even in the same set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">mode</td><td>Active / Inactive </td></tr>
    <tr><td class="paramname">event_object_set</td><td><a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a> of events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> are not the same type. </dd>
<dd>
false - successfully added <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a> </dd></dl>

</div>
</div>
<a id="ab02fabbde1b738b3b7ad020d0cb9c9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02fabbde1b738b3b7ad020d0cb9c9d3">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>event_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new event to the set. If the set with that name do not exist, then it creates a new set. It can be used to adds a new functionality to the existing set. Event will be stored depending on its interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">mode</td><td>Active / Inactive </td></tr>
    <tr><td class="paramname">event_object</td><td>Event that will be put into event set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if event object have a different type than rest of the <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd>
<dd>
false - successfully added <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd></dl>

</div>
</div>
<a id="ad75c6ac553c7672e26b78da2de6a3016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75c6ac553c7672e26b78da2de6a3016">&#9670;&nbsp;</a></span>addNew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::addNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_event_1_1_set.html">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>event_object_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new event set. If the event set with that name exists, it will return a value. All events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> must be the same type. Depending on the type set will be used as ordinary event or as event that can toggle other events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">mode</td><td>Active / Inactive </td></tr>
    <tr><td class="paramname">event_object_set</td><td><a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a> of events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if set with a name that exists before or events in <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Event::Set</a> are not the same type. </dd>
<dd>
false - successfully added <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd></dl>

</div>
</div>
<a id="a4071b96640a00c589a94ebe76bd75b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4071b96640a00c589a94ebe76bd75b9a">&#9670;&nbsp;</a></span>addNew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::addNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>event_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new event. If the event set with that name existed before, it will return a value. Event will be stored depending on its interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">mode</td><td>Active / Inactive </td></tr>
    <tr><td class="paramname">event_object</td><td>Event that will be put into event set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if set with that name existed before. </dd>
<dd>
false - successfully added <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd></dl>

</div>
</div>
<a id="a8a2f4e4ae4918203856a24f9797a2315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2f4e4ae4918203856a24f9797a2315">&#9670;&nbsp;</a></span>changeMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::changeMode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_event_1_1_manager.html#ad643d7f34cb7ae4ceb7dda35f5c2f278">Manager::State</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change mode to Active / Inactive. It can be used on both type of events. </p>
<p>The effect will take place on the next checkEvents call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">mode</td><td>Active / Inactive in namespace of this class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - cannot find <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a> with this name. </dd>
<dd>
false - mode was changed. </dd></dl>

</div>
</div>
<a id="a55cd38b7da27595f380e4462b985ad1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cd38b7da27595f380e4462b985ad1b">&#9670;&nbsp;</a></span>checkEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Manager::checkEvents </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Event &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run and check occurence in all active events. While using it, it checks if vector is sorted. If not then it performs a simple sort on binary values with computational complexity O(n) which is not heavy assumed that there will be only several dozens of sets. </p>
<p>At first it checks the normal Events and after that it checks Events that can change mode of other events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window where the event occurred. </td></tr>
    <tr><td class="paramname">event</td><td>An event that was already fetched from an event stack on this window. There may be a lot of events on stack, so it's recommended to do it in loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67bd2bca85508b0faa40edce7152c2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bd2bca85508b0faa40edce7152c2c9">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the set of events identified by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if operation was unsuccessful. It means that there is no event set with that name. </dd>
<dd>
false - successfully removed entire <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd></dl>

</div>
</div>
<a id="a38142bb61b9ed3c0acfd27ef68c3264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38142bb61b9ed3c0acfd27ef68c3264e">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_event_1_1_interface.html">Interface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>event_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove specific event from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier </td></tr>
    <tr><td class="paramname">event_object</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if operation was unsuccessful. It means that there is no event set with that name. </dd>
<dd>
false - successfully removed Event from <a class="el" href="class_event_1_1_set.html" title="Set used to group events. It can be passed to the Event::Manager.">Set</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a91a0fd9819101372b9d68ca08cc0c5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a0fd9819101372b9d68ca08cc0c5da">&#9670;&nbsp;</a></span>enents_change_control_map_names_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Map Event::Manager::enents_change_control_map_names_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map names with event sets that is used for events, that change state of other events in this <a class="el" href="class_event_1_1_manager.html" title="Stores events that can be active or not.">Manager</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/main/event/<a class="el" href="event_2_manager_8h_source.html">Manager.h</a></li>
<li>source/main/event/Manager.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
